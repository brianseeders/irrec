package ceedubs.irrec
package regex.applicative
// TODO package

import ceedubs.irrec.regex.{RegexGen => RegexGenOld}
import ceedubs.irrec.regex.{RegexMatchGen => RegexMatchGenOld}
import Regex.Regex
import ceedubs.irrec.regex.Match

import org.scalacheck.{Arbitrary, Cogen, Gen}
import cats.Order
import cats.implicits._

final case class RegexAndCandidate[In, Out](r: Regex[In, Out], candidate: Stream[In])

object RegexAndCandidate {
  /**
   * Generate a regular expression and a stream that matches the regular expression.
   */
  def genRegexAndMatch[In:Cogen:Order, Out:Arbitrary](
    cfg: RegexGenOld.Config[In],
    matchToGen: Match[In] => Gen[In]): Gen[RegexAndCandidate[In, Out]] =
    for {
      r <- RegexGen.genRegex[In, Out](cfg)
      c <- RegexMatchGen.regexMatchingStreamGen(matchToGen)(r)
    } yield RegexAndCandidate(r, c)

  def genIntRegexAndMatch[Out:Arbitrary]: Gen[RegexAndCandidate[Int, Out]] =
    genRegexAndMatch(RegexGenOld.standardIntConfig, RegexMatchGenOld.intMatchingGen)

  // TODO universal instead of existential type for Regex[In, _]?
  /**
   * About half of the streams generated by this generator will match the provided regular
   * expression. The other half will be random streams which _could_ match the expression but are
   * unlikely to.
   *
   * @see also [[genRegexAndMatch]].
   */
  def genCandidateStream[In](matchToGen: Match[In] => Gen[In]): Regex[In, _] => Gen[Stream[In]] = {
    val matching = RegexMatchGen.regexMatchingStreamGen(matchToGen)
    r => Gen.oneOf(matching(r), Gen.containerOf[Stream, In](matchToGen(Match.wildcard)))
  }

  /**
   * Generates arbitrary regexes and candidate matches for the regex. The candidate will match the
   * regex roughly 50% of the time.
   */
  def genRegexAndCandidate[In:Cogen:Order, Out:Arbitrary](
    cfg: RegexGenOld.Config[In],
    matchToGen: Match[In] => Gen[In]): Gen[RegexAndCandidate[In, Out]] = {
    val probablyNotMatching = for {
      r <- RegexGen.genRegex[In, Out](cfg)
      c <- Gen.containerOf[Stream, In](cfg.genA)
    } yield RegexAndCandidate(r, c)

    Gen.oneOf(probablyNotMatching, genRegexAndMatch[In, Out](cfg, matchToGen))
  }

  implicit def arbRegexAndCandidateByte[Out:Arbitrary]: Arbitrary[RegexAndCandidate[Byte, Out]] = Arbitrary(
    genRegexAndCandidate(RegexGenOld.standardByteConfig, RegexMatchGenOld.byteMatchingGen))

  implicit def arbRegexAndCandidateInt[Out:Arbitrary]: Arbitrary[RegexAndCandidate[Int, Out]] = Arbitrary(
    genRegexAndCandidate(RegexGenOld.standardIntConfig, RegexMatchGenOld.intMatchingGen))

  implicit def arbRegexAndCandidateLong[Out:Arbitrary]: Arbitrary[RegexAndCandidate[Long, Out]] = Arbitrary(
    genRegexAndCandidate(RegexGenOld.standardLongConfig, RegexMatchGenOld.longMatchingGen))
}
